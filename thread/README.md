线程安全性

定义:

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，
并且在主调度代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，name就称这个
类是线程安全的。

体现:

1.原子性: 提供了互斥访问，同一时间只能有一个线程来对它进行操作

2.可见性: 一个线程对主内存的修改可以及时的被其他线程观察到

3.有序性: 一个线程观察其他线程中的指令执行顺序，由于指令重排，该观察结果一般杂乱无序

实现:

atomic 

Synchronized 同步锁

作用范围:

1.修饰代码块: 大括号括起来的代码，作用于调用的对象

2.修饰方法: 整个方法，作用于调用的对象

3.修饰静态方法: 整个静态方法，作用于所有对象

4.修饰类: 括号括起来的部分，作用于所有对象

可见性(synchronized and volatile)

针对synchronized:

1.线程解锁前，必须把共享变量的最新值刷新到主内存

2.线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读入
最新的值，(前提是加锁和解锁是同一把锁的情况下)

针对volatile(通过加入内存屏障和禁止重排序优化来实现):

1.对volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享
变量刷新到主内存中去

2.对volatile变量进行读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享
变量

有序性

1.java内存模型中，允许编译器和处理器对指令进行重排序，重排序不会影响到单线程程序的执行
，却会影响到多线程并发执行的正确性

volatile、synchronized、lock能保证有序性

happens-before原则






















 